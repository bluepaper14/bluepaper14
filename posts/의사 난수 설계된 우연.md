---
title: "의사 난수: 설계된 우연"
date: Thu, 12 Feb 2026 06:23:34 GMT
url: "https://velog.io/@bluepaper14_/%ED%8C%8C%EC%9D%B4%EC%8D%AC-random%EC%9D%80-%EC%A7%84%EC%A7%9C-%EB%AC%B4%EC%9E%91%EC%9C%84%EC%9D%BC%EA%B9%8C"
tags: [velog, backup]
---

# [의사 난수: 설계된 우연](https://velog.io/@bluepaper14_/%ED%8C%8C%EC%9D%B4%EC%8D%AC-random%EC%9D%80-%EC%A7%84%EC%A7%9C-%EB%AC%B4%EC%9E%91%EC%9C%84%EC%9D%BC%EA%B9%8C)

### random 함수를 짚어보며..

최근에 파이썬 random 함수를 이용해서 코드를 작성하였다. 다만 최근 유튜브 영상에 프로그램의 random함수는 컴퓨터의 난수. 의사
난수라고 등장하어 직접 재현하고 테스트 코드를 작성해보자.

### random함수를 써볼까?

    
    
    from random import *
    
    x = randint(1, 100) #1 ~ 100사이의 정수 반환
    print(x)

이런식으로 random()함수 말고 다양한 방법이 있긴하다. 그럼 무작위인지 아닌지를 증명을 하려면 어떻게 해야할까..일단 확률적인
프로그램을 하나 재현해보자.

### 강화 확률 시뮬레이션

    
    
    from random import *
    
    x = randint(1, 100)
    if x <= 10: 
        print("10%확률로 강화가 성공했습니다.")
    
    else :
        print("10% 확률로 강화를 실패하였습니다.")

이렇게 코드를 실행하면 10%확률로 강화가 된다. 그럼 이를 for문으로 돌려 확률적으로 가까워지는지 확인해보자.

### 10% 확률 수렴 시뮬레이션

    
    
    from random import *
    
    trials = 123 # 시도
    success = 0 # 성공할때 마다 +
    
    for i in range(trials):
        x = randint(1, 100)
        if x <= 10:
            success += 1
    
    sucess_rate = (success / trials) * 100
    
    print(f"총 {trials}번 시도 중 {success}번 성공!")
    print(f"최종 성공 확률: {sucess_rate:.10f}%")
    
    error = abs(10 - sucess_rate)
    print(f"오차: {error:.10f}%")

이렇게 시행횟수를 늘려보면 결국 10%로 수렴하는 것을 볼수 있다.

    
    
    총 123번 시도 중 16번 성공!
    최종 성공 확률: 13.0081300813%
    오차: 3.0081300813%
    
    총 1234번 시도 중 120번 성공!
    최종 성공 확률: 9.7244732577%
    오차: 0.2755267423%
    
    총 12345번 시도 중 1214번 성공!
    최종 성공 확률: 9.8339408667%
    오차: 0.1660591333%
    
    총 123456번 시도 중 12260번 성공!
    최종 성공 확률: 9.9306635562%
    오차: 0.0693364438%

### 결정론적 알고리즘

컴퓨터의 무작위는 특정 수학공식의 결과물이다. 시드값으로 시작점을 정하고 랜덤을 시행하는데 보통 컴퓨터는 시드값으로 _현재시간_ 을
사용한다. 그럼 반대로 동일한 시드값을 입력하면 똑같은 무작위 숫자가 같은 순서로 출력된다는거다!

이것이 바로 결정론적 알고리즘이다.

### 상황 예제

그렇다면 특정 시드값에 무언가 버그가 일어난다고 가정할때 해당 시드를 고정해보자.

    
    
    seed(42)
    
    총 123456번 시도 중 12309번 성공!
    최종 성공 확률: 9.9703538103%
    오차: 0.0296461897%
    
    총 123456번 시도 중 12309번 성공!
    최종 성공 확률: 9.9703538103%
    오차: 0.0296461897%

이렇게 import 하단에 추가해보면 동일한 의사 난수로 인해 동일한 확률로 출력됨을 볼 수 있다.

그럼 위험한건 같은 시드로 인해 사용자가 똑같은 랜덤 결과를 받는 경우도 있는지 조사해봤다.

### 이론적으로 시드값이 겹치진 않는다

그렇다 현실적으론 시드값으로 사용하는 time()함수는 초단위이기에 동시 접속자가 많다면 동일한 시드값으로 같은 _무작위 결과_ 를 받을 수
있지만 요즘은 밀리초 마이크로초로 정밀한 시간을 시드로 사용한다.

하지만 보안적으로 시드값을 이용해서난수를 대조해서 시드값과 일치할때까지 난수를 맞춰 확률을 예측할 수도 있다.  
이런 악용을 막기 위해 실제는 ramdom 대신 secrets 모듈을 사용해서 예측이 불가능하게 한다.



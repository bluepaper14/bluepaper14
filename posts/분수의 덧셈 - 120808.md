---
title: "분수의 덧셈 - 120808"
date: Tue, 23 Dec 2025 13:05:18 GMT
url: "https://velog.io/@bluepaper14_/%EB%B6%84%EC%88%98%EC%9D%98-%EB%8D%A7%EC%85%88-120808"
tags: [velog, backup]
---

# [분수의 덧셈 - 120808](https://velog.io/@bluepaper14_/%EB%B6%84%EC%88%98%EC%9D%98-%EB%8D%A7%EC%85%88-120808)

### 문제 설명

첫 번째 분수의 분자와 분모를 뜻하는 `numer1`, `denom1`, 두 번째 분수의 분자와 분모를 뜻하는 `numer2`,
`denom2`가 매개변수로 주어집니다. 두 분수를 더한 값을 기약 분수로 나타냈을 때 분자와 분모를 순서대로 담은 배열을 return
하도록 solution 함수를 완성해보세요.

* * *

##### 제한사항

  * 0 <`numer1`, `denom1`, `numer2`, `denom2` < 1,000

* * *

##### 입출력 예

numer1 | denom1 | numer2 | denom2 | result  
---|---|---|---|---  
1 | 2 | 3 | 4 | [5, 4]  
9 | 2 | 1 | 3 | [29, 6]  
  
* * *

##### 입출력 예 설명

입출력 예 #1

  * 1 / 2 + 3 / 4 = 5 / 4입니다. 따라서 [5, 4]를 return 합니다.

입출력 예 #2

  * 9 / 2 + 1 / 3 = 29 / 6입니다. 따라서 [29, 6]을 return 합니다.

### 문제정의

이번 문제는 두 분수의 합을 구하는 프로그램을 만들면 된다. 그런데 최종 결과를 반드시 기약분수 형태로 출력해야 한다는 점이 문제였다.
그래서 우선 두 분수를 통분하여 합산하고 계산된 분자와 분모의 최대공약수를 구하여 각각 나누어주는 방식을 선택했다.

기약분수라는 조건이 어려웠지만 공통으로 나눌 수 있는 가장 큰 수를 찾아 약분하면 문제를 명확하게 해결할 수 있었다.

### 초기코드

    
    
    #include <string>
    #include <vector>
    
    using namespace std;
    
    vector<int> solution(int numer1, int denom1, int numer2, int denom2) {
        vector<int> answer;
        return answer;
    }

vector 설명 및 출력 형식으로 되어 있다. answer.push_back(ansnumer); 이렇게 추가만 해주면 배열에 삽입되어
출력가능하다.

    
    
    #include <iostream>
    #include <string>
    #include <vector>
    
    using namespace std;
    
    vector<int> solution(int numer1, int denom1, int numer2, int denom2) {
        vector<int> answer;
        int x = 0;
        int y = 0;
        int glc = 0;
    
        int bigdenom = denom1 * denom2; // 공통분모
        int numerx = numer1 * (bigdenom / denom1);
        int numery = numer2 * (bigdenom / denom2);
    
        int bignumer = numerx + numery; // 분자
    
        if (bigdenom > bignumer) { //만약. 분모가 분자보다 클때
            glc = bignumer;
            for (int i = glc; i >= 1; i--) {
                if (bigdenom % i == 0 && bignumer % i == 0) {
                    glc = i;
                    break;
                }
            }
        }
        else {
            glc = bigdenom;
            for (int i = glc; i >= 1; i--) {
                if (bigdenom % i == 0 && bignumer % i == 0) {
                    glc = i;
                    break;
                }
            }
        }
        int ansnumer = bignumer / glc;
        int ansdenom = bigdenom / glc;
    
        answer.push_back(ansnumer); // 일단 계산된 분자를 넣음
        answer.push_back(ansdenom); // 일단 계산된 분모를 넣음
    
        return answer;
    }

내가 작성한 코드지만 가독성이 없어 다른 방법은 없을까 찾아봤다.

    
    
    #include <string>
    #include <vector>
    
    using namespace std;
    
    vector<int> solution(int denum1, int num1, int denum2, int num2) {
        vector<int> answer;
        int denum = (denum1 * num2) + (denum2 * num1); //한번에 통분하여 분자를 만들어냄
        int num = num1 * num2; //분모 계산
    
        for(int i = min(denum, num); i >= 2 ; i--) //min을 사용해서 더 작은값을 추출. 분기x
        {
            if(denum % i == 0 && num % i == 0)
            {
                denum /= i;
                num /= i;
                break;
            }
        }
        answer.push_back(denum);
        answer.push_back(num);
    
        return answer;
    }
    

쓸데없는 분기, 변수 모두 줄였다.

### 기억해야하는점

> 정확한 코드라도 더 분기와 변수를 줄일수 있는 산술, 그리고 문법들을 숙지하자.



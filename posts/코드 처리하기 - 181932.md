---
title: "코드 처리하기 - 181932"
date: Sun, 25 Jan 2026 14:52:44 GMT
url: "https://velog.io/@bluepaper14_/%EC%BD%94%EB%93%9C%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0-181932"
tags: [velog, backup]
---

# [코드 처리하기 - 181932](https://velog.io/@bluepaper14_/%EC%BD%94%EB%93%9C%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0-181932)

![](https://velog.velcdn.com/images/bluepaper14_/post/1d553743-1a24-401e-831d-f0c310fff8f6/image.png)

### 문제 설명

문자열 `code`가 주어집니다.  
`code`를 앞에서부터 읽으면서 만약 문자가 "1"이면 `mode`를 바꿉니다. `mode`에 따라 `code`를 읽어가면서 문자열
`ret`을 만들어냅니다.

`mode`는 0과 1이 있으며, `idx`를 0 부터 `code의 길이 - 1` 까지 1씩 키워나가면서 `code[idx]`의 값에 따라
다음과 같이 행동합니다.

  * `mode`가 0일 때 
    * `code[idx]`가 "1"이 아니면 `idx`가 짝수일 때만 `ret`의 맨 뒤에 `code[idx]`를 추가합니다.
    * `code[idx]`가 "1"이면 `mode`를 0에서 1로 바꿉니다.
  * `mode`가 1일 때 
    * `code[idx]`가 "1"이 아니면 `idx`가 홀수일 때만 `ret`의 맨 뒤에 `code[idx]`를 추가합니다.
    * `code[idx]`가 "1"이면 `mode`를 1에서 0으로 바꿉니다.

문자열 `code`를 통해 만들어진 문자열 `ret`를 return 하는 solution 함수를 완성해 주세요.

단, 시작할 때 `mode`는 0이며, return 하려는 `ret`가 만약 빈 문자열이라면 대신 "EMPTY"를 return 합니다.

* * *

##### 제한사항

  * 1 ≤ `code`의 길이 ≤ 100,000 
    * `code`는 알파벳 소문자 또는 "1"로 이루어진 문자열입니다.

* * *

##### 입출력 예

code | result  
---|---  
"abc1abc1abc" | "acbac"  
  
* * *

##### 입출력 예 설명

입출력 예 #1

  * `code`의 각 인덱스 `i`에 따라 다음과 같이 `mode`와 `ret`가 변합니다.

i | code[i] | mode | ret  
---|---|---|---  
0 | "a" | 0 | "a"  
1 | "b" | 0 | "a"  
2 | "c" | 0 | "ac"  
3 | "1" | 1 | "ac"  
4 | "a" | 1 | "ac"  
5 | "b" | 1 | "acb"  
6 | "c" | 1 | "acb"  
7 | "1" | 0 | "acb"  
8 | "a" | 0 | "acba"  
9 | "b" | 0 | "acba"  
10 | "c" | 0 | "acbac"  
  
따라서 "acbac"를 return 합니다.

### 문제정의

크게 문제없이 문제를 풀었다. 하지만 코드를 가독성 높이는 방법이 있기에 변형하려한다.

### 초기코드

    
    
    #include <string>
    #include <vector>
    
    using namespace std;
    
    string solution(string code) {
        string answer = "";
        return answer;
    }

아래는 내가 완성한 코드다.

    
    
    #include <string>
    #include <vector>
    
    using namespace std;
    
    string solution(string code) {
        string answer = "";
        int mode = 0;
        for(int i = 0; i < code.length(); i++) {
            if(code[i] == '1') {//문자열중 1이 있는지 판별
                if(mode == 0) //mode 변환
                    mode = 1;
                else
                    mode = 0;
            }
            if(code[i] != '1') {
            if(mode == 0 && i % 2 == 0) 
                    answer += code[i];
            if(mode == 1 && i % 2 != 0) 
                    answer += code[i]; 
            }
        }
    
        if (answer.empty()) return "EMPTY";
    
        return answer;
    }
    
    /*mode를 바꾸는 분기
    1.입력된 문자가 1이면 mode변경 -> 변경중엔 ret 변함없음
    2.mode가 0이고 i가 짝수일때만 code[i]를 추가
    3.mode가 1이고 i가 홀수일때만 code[i]를 추가 
    */

각 상황마다 만들어야할 분기를 정리해보고 코딩하면 무난하게 풀이 가능하다. 나도 mode를 bool로 사용하면 어떨까 생각했는데 다른
풀이자들은 bool을 사용해서 가독성을 높었다.

    
    
    string solution(string code) {
        string answer = "";
        bool mode = false; //bool 생성 초기는 ture 선언
        for(int i = 0; i < code.length(); i++) {
            if(code[i] == '1') {//문자열중 1이 있다면
            mode = !mode; //true -> false로
            }
            if(code[i] != '1') {
            if(mode == false && i % 2 == 0) 
                    answer += code[i];
            if(mode == true && i % 2 != 0) 
                    answer += code[i]; 
            }
        }
    
        if (answer.empty()) return "EMPTY";
    
        return answer;
    }

아래는 bool + switch문을 활용한 예제코드이다. 간단해보이지만 코드가 길어 기각했다.

    
    
    #include <string>
    #include <vector>
    
    using namespace std;
    
    string solution(string code) {
        string answer = "";
        //ture == 0 , false == 1
        bool mode = true;
        for(int i=0; i<code.length(); i++)
        {
            if(code[i] =='1')
                mode = !mode;
            switch(mode)
            {
                case true:
                    if(i%2 == 0)
                    {
                        if(code[i] != '1')
                            answer+= code[i];
                    }
                    break;
                case false:
                    if(i%2 != 0)
                    {
                        if(code[i] != '1')
                            answer+= code[i];
                    }
                    break;
            }
        }
        if(answer.empty())
            answer = "EMPTY";
        return answer;
    }

### 기억해야할점

> 각 분기를 명확히 정리하고 코드를 가독성 있게 만들 여러 방법을 생각해보자.



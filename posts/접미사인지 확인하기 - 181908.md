---
title: "접미사인지 확인하기 - 181908"
date: Wed, 21 Jan 2026 23:46:23 GMT
url: "https://velog.io/@bluepaper14_/%EC%A0%91%EB%AF%B8%EC%82%AC%EC%9D%B8%EC%A7%80%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-181908"
tags: [velog, backup]
---

# [접미사인지 확인하기 - 181908](https://velog.io/@bluepaper14_/%EC%A0%91%EB%AF%B8%EC%82%AC%EC%9D%B8%EC%A7%80%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-181908)

![](https://velog.velcdn.com/images/bluepaper14_/post/83ebe5da-9abc-4c49-a417-81ab227efbab/image.png)

### 문제 설명

어떤 문자열에 대해서 접미사는 특정 인덱스부터 시작하는 문자열을 의미합니다. 예를 들어, "banana"의 모든 접미사는 "banana",
"anana", "nana", "ana", "na", "a"입니다.  
문자열 `my_string`과 `is_suffix`가 주어질 때, `is_suffix`가 `my_string`의 접미사라면 1을, 아니면
0을 return 하는 solution 함수를 작성해 주세요.

* * *

##### 제한사항

  * 1 ≤ `my_string`의 길이 ≤ 100
  * 1 ≤ `is_suffix`의 길이 ≤ 100
  * `my_string`과 `is_suffix`는 영소문자로만 이루어져 있습니다.

* * *

##### 입출력 예

my_string | is_suffix | result  
---|---|---  
"banana" | "ana" | 1  
"banana" | "nan" | 0  
"banana" | "wxyz" | 0  
"banana" | "abanana" | 0  
  
* * *

##### 입출력 예 설명

입출력 예 #1

  * 예제 1번에서 `is_suffix`가 `my_string`의 접미사이기 때문에 1을 return 합니다.

입출력 예 #2

  * 예제 2번에서 `is_suffix`가 `my_string`의 접미사가 아니기 때문에 0을 return 합니다.

입출력 예 #3

  * 예제 3번에서 `is_suffix`가 `my_string`의 접미사가 아니기 때문에 0을 return 합니다.

입출력 예 #4

  * 예제 4번에서 `is_suffix`가 `my_string`의 접미사가 아니기 때문에 0을 return 합니다.

### 문제정의

문제 접근을 어떻게 해야할지 고민이었다. 접미사를 어떻게 생성하고 비교해야할지 의문이었다.

  1. 접미사를 만들기
  2. 접미사를 대조하기

### 초기코드

    
    
    #include <string>
    #include <vector>
    
    using namespace std;
    
    int solution(string my_string, string is_suffix) {
        int answer = 0;
        return answer;
    }

처음 나는 접미사를 생성할때 substr이라는 함수를 사용하였다.

    
    
    string result = original.substr(시작위치, 길이);

original에 대당 배열을 넣고 함수를 사용하여 길이를 지정하게 되면 특정 길이의 배열을 출력할 수 있다. 예를 들어보자.

    
    
    string s = "Hello-World";
    string sub = s.substr(6); // "World" (6번 인덱스부터 끝까지)

이렇게 처리하면 접미사들을 반복문을 통해 뽑아낼수 있다. 다만 내가 잘못생각한건 _해당 배열을 vector나 새로운 배열을 만들어 삽입해서
비교하려했다. 그래서 구현도 안그려지도 복잡했다. 애초에 대입할 배열을 만들지 않고 바로 판별하도록 만들었다_

최종적으로 비교군이 같다면 바로 1을 대입하여 break로 탈출하였다.

    
    
    #include <string>
    #include <vector>
    
    using namespace std;
    
    int solution(string my_string, string is_suffix) {
        int answer = 0;
        string name;
    
        for(int i = 0; i < my_string.length(); i++) {
        name = my_string.substr(i);
        if(name == is_suffix) {
            answer = 1;
            break;
        }
    }
    
        return answer;
    }

다른 방법이 있다면

    
    
    #include <string>
    #include <vector>
    
    using namespace std;
    
    int solution(string my_string, string is_suffix) {    
        if(my_string.size() < is_suffix.size())
        {
            return 0;
        }
        return my_string.substr(my_string.size() - is_suffix.size()) == is_suffix;
    }

좋은 코드이다. 일단 if문으로 비교군이 현재 접미사보다 크다면 0을 리턴하여 우선적으로 절대 접미사가 될 수 없는 것들을 제거하였다.

    
    
    return my_string.substr(my_string.size() - is_suffix.size()) == is_suffix;

또한 각 비교군의 차를 이용했다. 왜냐하면 문자를 비교하려면 일단 비교되는 문자의 크기부터 끝까지 크기를 구해 substr를 사용해 인덱스
끝까지 잘랐다.

최종적으로 방금 자른 것이 비교군과 같은지 비교하여 맞다면 리턴하였다.

### 기억해야하는점

> s.substr(n) 처럼 인자로 시작 위치(n)만 전달하면, 그 위치부터 문자열 끝까지 잘라준다.



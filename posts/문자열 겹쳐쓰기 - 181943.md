---
title: "문자열 겹쳐쓰기 - 181943"
date: Tue, 20 Jan 2026 11:54:29 GMT
url: "https://velog.io/@bluepaper14_/%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B2%B9%EC%B3%90%EC%93%B0%EA%B8%B0-181943"
tags: [velog, backup]
---

# [문자열 겹쳐쓰기 - 181943](https://velog.io/@bluepaper14_/%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B2%B9%EC%B3%90%EC%93%B0%EA%B8%B0-181943)

![](https://velog.velcdn.com/images/bluepaper14_/post/d90fd118-5546-4118-a8f0-e3b507f4e4ab/image.png)

### 문제 설명

문자열 `my_string`, `overwrite_string`과 정수 `s`가 주어집니다. 문자열 `my_string`의 인덱스 `s`부터
`overwrite_string`의 길이만큼을 문자열 `overwrite_string`으로 바꾼 문자열을 return 하는 solution
함수를 작성해 주세요.

* * *

##### 제한사항

  * `my_string`와 `overwrite_string`은 숫자와 알파벳으로 이루어져 있습니다.
  * 1 ≤ `overwrite_string`의 길이 ≤ `my_string`의 길이 ≤ 1,000
  * 0 ≤ `s` ≤ `my_string`의 길이 - `overwrite_string`의 길이

* * *

##### 입출력 예

my_string | overwrite_string | s | result  
---|---|---|---  
"He11oWor1d" | "lloWorl" | 2 | "HelloWorld"  
"Program29b8UYP" | "merS123" | 7 | "ProgrammerS123"  
  
* * *

##### 입출력 예 설명

입출력 예 #1

  * 예제 1번의 `my_string`에서 인덱스 2부터 `overwrite_string`의 길이만큼에 해당하는 부분은 "11oWor1"이고 이를 "lloWorl"로 바꾼 "HelloWorld"를 return 합니다.

입출력 예 #2

  * 예제 2번의 `my_string`에서 인덱스 7부터 `overwrite_string`의 길이만큼에 해당하는 부분은 "29b8UYP"이고 이를 "merS123"로 바꾼 "ProgrammerS123"를 return 합니다.

### 초기 코드

    
    
    #include <string>
    #include <vector>
    
    using namespace std;
    
    string solution(string my_string, string overwrite_string, int s) {
        string answer = "";
        return answer;
    }

### 문제정의

처음에는 my_string의 시작점 s를 기준으로 단순히 문자열을 덮어붙이면 된다고 생각했다.

    
    
    #include <iostream>
    #include <string>
    #include <vector>
    
    using namespace std;
    
    string solution(string my_string, string overwrite_string, int s) {
        string answer = "";
        for(int i = 0; i < s; i++) {
            answer += my_string[i];
        } //정답 문자열에 먼저 my_string 대입
    
        for(int i = s; i < overwrite_string.length(); i++) {
            answer += overwrite_string[i];
        } //정답 문자열에 s기준으로 덮어씌우기
        return answer;
    }

결과는 이렇다.

    
    
    입력값 〉     "He11oWor1d", "lloWorl", 2
    기댓값 〉     "HelloWorld"
    결과값 〉    "HeoWorl"
    
    입력값 〉    "Program29b8UYP", "merS123", 7
    기댓값 〉    "ProgrammerS123"
    결과값 〉    "Program"

반복문에서 i = s부터 시작하면서 overwrite_string[i]를 참조했기 때문에 설계가 잘못되었다.

그럼 배열의 값을 s 만큼 빼고 시작하면?

    
    
    입력값 〉     "He11oWor1d", "lloWorl", 2
    기댓값 〉     "HelloWorld"
    결과값 〉    "HelloWo"
    
    입력값 〉    "Program29b8UYP", "merS123", 7
    기댓값 〉    "ProgrammerS123"
    결과값 〉    "Program"

인덱스를 0부터 참조하도록 수정했음에도 기댓값보다 문자열이 짧게 출력되었다.

    
    
        for(int i = s + overwrite_string.length(); i < my_string.length(); i++) {
            answer += my_string[i];
        }

i의 초기값을 기존 s + 덮어씌우는 문자열의 크기로 지정하여 시작점을 두고 초기 문자열을 마지막으로 크기를 둬서 문자열에 삽입될 수 있도록
하였다.

###

    
    
    #include <iostream>
    #include <string>
    
    using namespace std;
    
    string solution(string my_string, string overwrite_string, int s) {
        string answer = "";
    
        // 1. 앞부분: s 이전까지 그대로 복사
        for(int i = 0; i < s; i++) {
            answer += my_string[i];
        }
    
        // 2. 중간부분: overwrite_string을 통째로 넣기
        for(int i = 0; i < overwrite_string.length(); i++) {
            answer += overwrite_string[i];
        }
    
        // 3. 뒷부분: 원래 문자열에서 덮어쓰고 남은 나머지 복사
        // 시작 지점은 '시작위치(s) + 덮어쓴 길이'가 됩니다.
        for(int i = s + overwrite_string.length(); i < my_string.length(); i++) {
            answer += my_string[i];
        }
    
        return answer;
    }

### 기억해야할점

> 각 문자열로부터 반복문을 사용할때 디버깅을 똑바로하자.


